import React, { useState, useEffect, useContext, useMemo, useRef, useCallback } from 'react';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// eslint-disable-next-line
/// <reference types="@types/googlemaps" />
/**
 * A Google Maps wrapper class
 */
class GoogleMap {
  constructor(options) {
    this.container = void 0;
    this.map = void 0;
    this.destroyListeners = () => {
      if (this.map) {
        google.maps.event.clearInstanceListeners(this.map);
      }
    };
    this.destroyComplete = () => {
      if (this.map) {
        document.querySelectorAll('script[src^="https://maps.googleapis.com"]').forEach(script => {
          script.remove();
        });
        if (window.google && window.google.maps) {
          // @ts-ignore: The operand of a 'delete' operator must be optional.
          delete window.google.maps;
        }
      }
    };
    if (window.google && window.google.maps) {
      this.initMap(options);
    } else {
      this.loadGoogleScript(options);
    }
  }
  /**
   * Loads the google maps script
   */
  loadGoogleScript(options) {
    const scriptTag = document.createElement('script');
    const defaultLanguage = window.navigator.language.slice(0, 2);
    const defaultRegion = window.navigator.language.slice(3, 5);
    const {
      libraries,
      mapIds,
      version,
      language,
      region,
      googleMapsAPIKey,
      onLoadScript
    } = options;
    scriptTag.setAttribute('type', 'text/javascript');
    scriptTag.setAttribute('src', `https://maps.googleapis.com/maps/api/js?key=${googleMapsAPIKey}&language=${language || defaultLanguage}&region=${region || defaultRegion}${libraries ? `&libraries=${libraries.join(',')}` : ''}${mapIds ? `&map_ids=${mapIds.join(',')}` : ''}${version ? `&v=${version}` : ''}`);
    scriptTag.onload = () => {
      onLoadScript();
      this.initMap(options);
    };
    document.getElementsByTagName('head')[0].appendChild(scriptTag);
  }
  /**
   * Initialize the google map
   */
  initMap(options) {
    const {
      container,
      config
    } = options;
    this.container = container;
    this.map = new google.maps.Map(this.container, config);
    google.maps.event.addListenerOnce(this.map, 'idle', () => {
      this.map && options.onLoadMap(this);
    });
  }
  /**
   * Remove event listeners
   */
}

/**
 * The map context
 */
const GoogleMapContext = React.createContext({
  loading: true
});
/**
 * The global Google Map provider
 */
const GoogleMapProvider = props => {
  const {
    children,
    googleMapsAPIKey,
    mapContainer,
    options,
    libraries,
    language,
    region,
    mapIds,
    version,
    onLoad
  } = props;
  const [loading, setLoading] = useState(true);
  const [map, setMap] = useState();
  const createGoogleMap = () => {
    if (!mapContainer) {
      return;
    }
    const mapOptions = {
      container: mapContainer,
      googleMapsAPIKey,
      onLoadScript: () => setLoading(false),
      onLoadMap: loadedMap => {
        setMap(loadedMap);
        if (typeof onLoad === 'function' && loadedMap.map) {
          onLoad(loadedMap.map);
        }
      },
      config: options,
      libraries,
      mapIds,
      language,
      region,
      version
    };
    // Create Google Map instance
    new GoogleMap(mapOptions);
  };
  // Destroy Google Map when component unmounts
  useEffect(() => map && map.destroyComplete(), []);
  // Destroy and recreate map on mapcontainer change
  useEffect(() => {
    if (!mapContainer) {
      return;
    }
    if (map) {
      // Destroy old map instance listeners
      map.destroyListeners();
    }
    // create new map instance
    createGoogleMap();
  }, [mapContainer]);
  // Destroy and recreate map on language or region change
  useEffect(() => {
    if (!map) {
      return;
    }
    // Destroy old map instance
    map.destroyComplete();
    // create new map instance
    createGoogleMap();
  }, [language, region]);
  return React.createElement(GoogleMapContext.Provider, {
    value: _extends({}, map, {
      loading
    })
  }, children);
};

/**
 * Hook to get global map instance
 */
const useGoogleMap = () => useContext(GoogleMapContext);

/**
 * Hook to get Google Maps Places Service instance
 */
const usePlacesService = () => {
  const {
    map
  } = useGoogleMap();
  // Creates a Places Service instance
  const placesService = useMemo(() => {
    // Wait for map to be initialized
    if (!map) {
      return null;
    }
    if (!google.maps.places) {
      throw Error("Places library missing. Add 'places' to the libraries array of GoogleMapProvider.");
    }
    return new google.maps.places.PlacesService(map);
  }, [map]);
  return placesService;
};

/**
 * Hook to get a Google Maps Places Autocomplete instance
 * monitoring an input field
 */
const useAutocomplete = props => {
  const {
    inputField,
    options,
    onPlaceChanged
  } = props;
  const placeChangedHandler = useRef(onPlaceChanged);
  const {
    map
  } = useGoogleMap();
  const [autocomplete, setAutocomplete] = useState(null);
  // Initializes the Google Maps Places Autocomplete
  useEffect(() => {
    // Wait for map and input element to be initialized
    if (!map || !inputField) {
      return () => {};
    }
    if (!google.maps.places) {
      throw Error("Autocomplete library missing. Add 'places' to the libraries array of GoogleMapProvider.");
    }
    // Create Autocomplete instance
    const autocompleteInstance = new google.maps.places.Autocomplete(inputField, options);
    setAutocomplete(autocompleteInstance);
    // Add places change listener to Autocomplete
    autocompleteInstance.addListener('place_changed', () => {
      const place = autocompleteInstance.getPlace();
      placeChangedHandler.current && placeChangedHandler.current(place);
    });
    // Clear listeners on unmount
    return () => {
      autocompleteInstance && google.maps.event.clearInstanceListeners(autocompleteInstance);
    };
  }, [map, inputField, options]);
  return autocomplete;
};

/**
 * Hook to get Google Maps Places Directions Service instance
 */
const useDirections = (props = {}) => {
  const {
    renderOnMap,
    renderOptions
  } = props;
  const {
    map,
    loading
  } = useGoogleMap();
  // Creates a Directions Service instance
  const directionsService = useMemo(() => {
    // Wait for map to be initialized
    if (!map || loading) {
      return null;
    }
    return new google.maps.DirectionsService();
  }, [map, loading]);
  // Creates a Directions Renderer instance
  const directionsRenderer = useMemo(() => {
    // Wait for map to be initialized
    if (!map || !renderOnMap) {
      return null;
    }
    const renderer = new google.maps.DirectionsRenderer(renderOptions);
    renderer.setMap(map);
    return renderer;
  }, [map, renderOnMap]);
  // Updates the directions renderer options
  useEffect(() => {
    if (!directionsRenderer) {
      return;
    }
    directionsRenderer.setOptions(renderOptions || {});
  }, [renderOptions]);
  // Custom Directions route request
  const findRoute = useCallback(request => new Promise((resolve, reject) => {
    if (directionsService) {
      directionsService.route(request, (result, status) => {
        if (status === google.maps.DirectionsStatus.OK) {
          resolve(result);
        } else {
          reject(status);
        }
      });
    }
  }), [directionsService]);
  // Custom Directions route request followed by directions rendering
  const findAndRenderRoute = useCallback(request => new Promise((resolve, reject) => {
    if (directionsService) {
      directionsService.route(request, (result, status) => {
        if (status === google.maps.DirectionsStatus.OK) {
          if (directionsRenderer) {
            directionsRenderer.setDirections(result);
          }
          resolve(result);
        } else {
          reject(status);
        }
      });
    }
  }), [directionsService, directionsRenderer]);
  // Renders directions route of given index
  const renderRouteOfIndex = index => {
    if (directionsRenderer) {
      directionsRenderer.setRouteIndex(index);
    }
  };
  return {
    directionsService,
    findRoute: directionsService && findRoute,
    findAndRenderRoute: directionsService && directionsRenderer && findAndRenderRoute,
    renderRouteOfIndex
  };
};

/**
 * Hook to get Google Maps Geocoder instance
 */
const useGeocoder = () => {
  const {
    map
  } = useGoogleMap();
  // Creates a Geocoder instance
  const geocoder = useMemo(() => {
    // Wait for Google Maps API to be initialized
    if (!map) {
      return null;
    }
    return new google.maps.Geocoder();
  }, [map]);
  return geocoder;
};

export { GoogleMapProvider, useAutocomplete, useDirections, useGeocoder, useGoogleMap, usePlacesService };
