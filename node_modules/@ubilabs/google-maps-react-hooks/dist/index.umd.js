(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.googleMapsReactHooks = {}, global.react));
})(this, (function (exports, React) {
  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  // eslint-disable-next-line
  /// <reference types="@types/googlemaps" />
  /**
   * A Google Maps wrapper class
   */
  var GoogleMap = /*#__PURE__*/function () {
    function GoogleMap(options) {
      var _this = this;
      this.container = void 0;
      this.map = void 0;
      this.destroyListeners = function () {
        if (_this.map) {
          google.maps.event.clearInstanceListeners(_this.map);
        }
      };
      this.destroyComplete = function () {
        if (_this.map) {
          document.querySelectorAll('script[src^="https://maps.googleapis.com"]').forEach(function (script) {
            script.remove();
          });
          if (window.google && window.google.maps) {
            // @ts-ignore: The operand of a 'delete' operator must be optional.
            delete window.google.maps;
          }
        }
      };
      if (window.google && window.google.maps) {
        this.initMap(options);
      } else {
        this.loadGoogleScript(options);
      }
    }
    /**
     * Loads the google maps script
     */
    var _proto = GoogleMap.prototype;
    _proto.loadGoogleScript = function loadGoogleScript(options) {
      var _this2 = this;
      var scriptTag = document.createElement('script');
      var defaultLanguage = window.navigator.language.slice(0, 2);
      var defaultRegion = window.navigator.language.slice(3, 5);
      var libraries = options.libraries,
        mapIds = options.mapIds,
        version = options.version,
        language = options.language,
        region = options.region,
        googleMapsAPIKey = options.googleMapsAPIKey,
        onLoadScript = options.onLoadScript;
      scriptTag.setAttribute('type', 'text/javascript');
      scriptTag.setAttribute('src', "https://maps.googleapis.com/maps/api/js?key=" + googleMapsAPIKey + "&language=" + (language || defaultLanguage) + "&region=" + (region || defaultRegion) + (libraries ? "&libraries=" + libraries.join(',') : '') + (mapIds ? "&map_ids=" + mapIds.join(',') : '') + (version ? "&v=" + version : ''));
      scriptTag.onload = function () {
        onLoadScript();
        _this2.initMap(options);
      };
      document.getElementsByTagName('head')[0].appendChild(scriptTag);
    }
    /**
     * Initialize the google map
     */;
    _proto.initMap = function initMap(options) {
      var _this3 = this;
      var container = options.container,
        config = options.config;
      this.container = container;
      this.map = new google.maps.Map(this.container, config);
      google.maps.event.addListenerOnce(this.map, 'idle', function () {
        _this3.map && options.onLoadMap(_this3);
      });
    }
    /**
     * Remove event listeners
     */;
    return GoogleMap;
  }();

  /**
   * The map context
   */
  var GoogleMapContext = React__default["default"].createContext({
    loading: true
  });
  /**
   * The global Google Map provider
   */
  var GoogleMapProvider = function GoogleMapProvider(props) {
    var children = props.children,
      googleMapsAPIKey = props.googleMapsAPIKey,
      mapContainer = props.mapContainer,
      options = props.options,
      libraries = props.libraries,
      language = props.language,
      region = props.region,
      mapIds = props.mapIds,
      version = props.version,
      onLoad = props.onLoad;
    var _useState = React.useState(true),
      loading = _useState[0],
      setLoading = _useState[1];
    var _useState2 = React.useState(),
      map = _useState2[0],
      setMap = _useState2[1];
    var createGoogleMap = function createGoogleMap() {
      if (!mapContainer) {
        return;
      }
      var mapOptions = {
        container: mapContainer,
        googleMapsAPIKey: googleMapsAPIKey,
        onLoadScript: function onLoadScript() {
          return setLoading(false);
        },
        onLoadMap: function onLoadMap(loadedMap) {
          setMap(loadedMap);
          if (typeof onLoad === 'function' && loadedMap.map) {
            onLoad(loadedMap.map);
          }
        },
        config: options,
        libraries: libraries,
        mapIds: mapIds,
        language: language,
        region: region,
        version: version
      };
      // Create Google Map instance
      new GoogleMap(mapOptions);
    };
    // Destroy Google Map when component unmounts
    React.useEffect(function () {
      return map && map.destroyComplete();
    }, []);
    // Destroy and recreate map on mapcontainer change
    React.useEffect(function () {
      if (!mapContainer) {
        return;
      }
      if (map) {
        // Destroy old map instance listeners
        map.destroyListeners();
      }
      // create new map instance
      createGoogleMap();
    }, [mapContainer]);
    // Destroy and recreate map on language or region change
    React.useEffect(function () {
      if (!map) {
        return;
      }
      // Destroy old map instance
      map.destroyComplete();
      // create new map instance
      createGoogleMap();
    }, [language, region]);
    return React__default["default"].createElement(GoogleMapContext.Provider, {
      value: _extends({}, map, {
        loading: loading
      })
    }, children);
  };

  /**
   * Hook to get global map instance
   */
  var useGoogleMap = function useGoogleMap() {
    return React.useContext(GoogleMapContext);
  };

  /**
   * Hook to get Google Maps Places Service instance
   */
  var usePlacesService = function usePlacesService() {
    var _useGoogleMap = useGoogleMap(),
      map = _useGoogleMap.map;
    // Creates a Places Service instance
    var placesService = React.useMemo(function () {
      // Wait for map to be initialized
      if (!map) {
        return null;
      }
      if (!google.maps.places) {
        throw Error("Places library missing. Add 'places' to the libraries array of GoogleMapProvider.");
      }
      return new google.maps.places.PlacesService(map);
    }, [map]);
    return placesService;
  };

  /**
   * Hook to get a Google Maps Places Autocomplete instance
   * monitoring an input field
   */
  var useAutocomplete = function useAutocomplete(props) {
    var inputField = props.inputField,
      options = props.options,
      onPlaceChanged = props.onPlaceChanged;
    var placeChangedHandler = React.useRef(onPlaceChanged);
    var _useGoogleMap = useGoogleMap(),
      map = _useGoogleMap.map;
    var _useState = React.useState(null),
      autocomplete = _useState[0],
      setAutocomplete = _useState[1];
    // Initializes the Google Maps Places Autocomplete
    React.useEffect(function () {
      // Wait for map and input element to be initialized
      if (!map || !inputField) {
        return function () {};
      }
      if (!google.maps.places) {
        throw Error("Autocomplete library missing. Add 'places' to the libraries array of GoogleMapProvider.");
      }
      // Create Autocomplete instance
      var autocompleteInstance = new google.maps.places.Autocomplete(inputField, options);
      setAutocomplete(autocompleteInstance);
      // Add places change listener to Autocomplete
      autocompleteInstance.addListener('place_changed', function () {
        var place = autocompleteInstance.getPlace();
        placeChangedHandler.current && placeChangedHandler.current(place);
      });
      // Clear listeners on unmount
      return function () {
        autocompleteInstance && google.maps.event.clearInstanceListeners(autocompleteInstance);
      };
    }, [map, inputField, options]);
    return autocomplete;
  };

  /**
   * Hook to get Google Maps Places Directions Service instance
   */
  var useDirections = function useDirections(props) {
    if (props === void 0) {
      props = {};
    }
    var _props = props,
      renderOnMap = _props.renderOnMap,
      renderOptions = _props.renderOptions;
    var _useGoogleMap = useGoogleMap(),
      map = _useGoogleMap.map,
      loading = _useGoogleMap.loading;
    // Creates a Directions Service instance
    var directionsService = React.useMemo(function () {
      // Wait for map to be initialized
      if (!map || loading) {
        return null;
      }
      return new google.maps.DirectionsService();
    }, [map, loading]);
    // Creates a Directions Renderer instance
    var directionsRenderer = React.useMemo(function () {
      // Wait for map to be initialized
      if (!map || !renderOnMap) {
        return null;
      }
      var renderer = new google.maps.DirectionsRenderer(renderOptions);
      renderer.setMap(map);
      return renderer;
    }, [map, renderOnMap]);
    // Updates the directions renderer options
    React.useEffect(function () {
      if (!directionsRenderer) {
        return;
      }
      directionsRenderer.setOptions(renderOptions || {});
    }, [renderOptions]);
    // Custom Directions route request
    var findRoute = React.useCallback(function (request) {
      return new Promise(function (resolve, reject) {
        if (directionsService) {
          directionsService.route(request, function (result, status) {
            if (status === google.maps.DirectionsStatus.OK) {
              resolve(result);
            } else {
              reject(status);
            }
          });
        }
      });
    }, [directionsService]);
    // Custom Directions route request followed by directions rendering
    var findAndRenderRoute = React.useCallback(function (request) {
      return new Promise(function (resolve, reject) {
        if (directionsService) {
          directionsService.route(request, function (result, status) {
            if (status === google.maps.DirectionsStatus.OK) {
              if (directionsRenderer) {
                directionsRenderer.setDirections(result);
              }
              resolve(result);
            } else {
              reject(status);
            }
          });
        }
      });
    }, [directionsService, directionsRenderer]);
    // Renders directions route of given index
    var renderRouteOfIndex = function renderRouteOfIndex(index) {
      if (directionsRenderer) {
        directionsRenderer.setRouteIndex(index);
      }
    };
    return {
      directionsService: directionsService,
      findRoute: directionsService && findRoute,
      findAndRenderRoute: directionsService && directionsRenderer && findAndRenderRoute,
      renderRouteOfIndex: renderRouteOfIndex
    };
  };

  /**
   * Hook to get Google Maps Geocoder instance
   */
  var useGeocoder = function useGeocoder() {
    var _useGoogleMap = useGoogleMap(),
      map = _useGoogleMap.map;
    // Creates a Geocoder instance
    var geocoder = React.useMemo(function () {
      // Wait for Google Maps API to be initialized
      if (!map) {
        return null;
      }
      return new google.maps.Geocoder();
    }, [map]);
    return geocoder;
  };

  exports.GoogleMapProvider = GoogleMapProvider;
  exports.useAutocomplete = useAutocomplete;
  exports.useDirections = useDirections;
  exports.useGeocoder = useGeocoder;
  exports.useGoogleMap = useGoogleMap;
  exports.usePlacesService = usePlacesService;

}));
